go:tell(Input) :-
    go:create_goal(
        go:respond(Input)
    );

go:respond(Input) :-

    [:Output := '']

    go:ignore(

        go:dialog_decrease_activation()
        go:find_locale(Locale)
        go:slot(locale, Locale)
        go:dialog_read_bindings(DialogBinding)
        go:tokenize(Locale, Input, InTokens)
        go:parse(Locale, InTokens, ParseTree)

        /* Stop at the first successfully processed parse tree */
        go:cut(1,
            go:check_agreement(ParseTree)
            go:dialogize(ParseTree, DialogParseTree)
            go:ellipsize(DialogParseTree, CompletedParseTree)
            go:extract_root_clauses(CompletedParseTree, RootClauseTree)
            go:process_root_clause(RootClauseTree, DialogBinding, Locale, RootClauseOutput, ContinueLooking)
            [:Output := RootClauseOutput]

            /* `ContinueLooking` tells us that there was a problem that should only be reported if no other parse tree succeeds */
            if [ContinueLooking == true] then
                fail
            end
        )
    )
    go:uuid(Uuid, entity)
    go:wait_for(
        go:print(Uuid, :Output)
    )
;

go:process_root_clause(RootClauseTree, DialogBinding, Locale, Output, ContinueLooking) :-

    go:dialog_add_root_clause(RootClauseTree, false)
    go:extract_tags(RootClauseTree)
    go:sortal_filtering(RootClauseTree)

    go:resolve_names(RootClauseTree, DialogBinding, RequestBinding, UnresolvedName)
    if [UnresolvedName != ''] then
        go:create_canned(Output, name_not_found, UnresolvedName)
        [ContinueLooking := true]
        return
    end

    go:relationize(RootClauseTree, Request)

    go:resolve_anaphora(RootClauseTree, Request, RequestBinding, UnusedTree, ResolvedRequest, ResolvedBindings, ResolvedOutput)
    if [ResolvedOutput != ''] then
        [Output := ResolvedOutput]
        [ContinueLooking := false]
        return
    end

    /* Stop at the first successfully processed intent */
    go:cut(1,
        go:detect_intent(ResolvedRequest, Intent)
        go:make_list(Intents, Intent)
        go:execute_intent(ResolvedRequest, ResolvedBindings, Intents, AnOutput, Accepted, AcceptedBindings)
        if [AnOutput != ''] then
             [Output := AnOutput]
             [ContinueLooking := false]
             return
        end
    )

    go:dialog_update_center()
    go:find_response(Accepted, AcceptedBindings, ResponseBindings, ResponseIndex)
    go:create_answer(Accepted, ResponseBindings, ResponseIndex, Answer, EssentialBindings)

    go:dialog_write_bindings(ResponseBindings)
    go:dialog_write_bindings(EssentialBindings)
    go:dialog_add_response_clause(EssentialBindings)
    go:generate(Locale, Answer, OutTokens)
    go:surface(OutTokens, Output)
    [ContinueLooking := false]
;

go:execute_intent(ResolvedRequest, ResolvedBindings, Intents, Output, Accepted, AcceptedBindings) :-
    go:list_length(Intents, SolSize)
    [LastSol := [SolSize - 1]]
    [:Output := '']
    [:Accepted := none]
    [:AcceptedBindings := none]

    go:list_foreach(Intents, Index, Sol,

        go:solve(ResolvedRequest, ResolvedBindings, Sol, ResultBindings, ResultCount)

        /* If there were Intents, good! */
        if [ResultCount > 0] then
            [:Accepted := Sol]
            [:AcceptedBindings := ResultBindings]
            [:Output := '']
            break
        end
        /* If this is the last available intent, take it anyway */
        if [LastSol == Index] then
            [:Accepted := Sol]
            [:AcceptedBindings := ResultBindings]
            [:Output := '']
            break
        end
    )
    [Output := :Output]
    [Accepted := :Accepted]
    [AcceptedBindings := :AcceptedBindings]
;