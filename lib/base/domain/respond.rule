go:tell(Input) :-
    go:create_goal(
        go:respond(Input)
    );

go:respond(Input) :-

    [:Output := '']

    go:ignore(

        go:find_locale(Locale)
        go:slot(locale, Locale)
        go:dialog_read_bindings(DialogBinding)
        go:tokenize(Locale, Input, InTokens)
        go:parse(Locale, InTokens, ParseTree)

        /* Stop at the first successfully processed parse tree */
        go:cut(1,
            go:dialogize(ParseTree, DialogParseTree)
            go:ellipsize(DialogParseTree, CompletedParseTree)
            go:extract_root_clauses(CompletedParseTree, RootClauseTree)
            go:process_root_clause(RootClauseTree, DialogBinding, Locale, RootClauseOutput, ContinueLooking)
            [:Output := RootClauseOutput]

            /* `ContinueLooking` tells us that there was a problem that should only be reported if no other parse tree succeeds */
            if [ContinueLooking == true] then
                fail
            end
        )
    )
    go:uuid(Uuid)
    go:wait_for(
        go:print(Uuid, :Output)
    )
;

go:process_root_clause(RootClauseTree, DialogBinding, Locale, Output, ContinueLooking) :-

    go:dialog_add_root_clause(RootClauseTree, false)

    go:relationize(RootClauseTree, Request)

    go:sortal_filtering(Request, DialogBinding)

    go:resolve_names(RootClauseTree, DialogBinding, RequestBinding, UnresolvedName)
    if [UnresolvedName != ''] then
        go:create_canned(Output, name_not_found, UnresolvedName)
        [ContinueLooking := true]
        return
    end

    go:resolve_anaphora(Request, RequestBinding, ResolvedRequest, ResolvedBindings, ResolvedOutput)
    if [ResolvedOutput != ''] then
        [Output := ResolvedOutput]
        [ContinueLooking := false]
        return
    end

    /* Stop at the first successfully processed solution */
    go:cut(1,
        go:find_solution(ResolvedRequest, Solution)
        go:make_list(Solutions, Solution)
        go:exec_solutions(ResolvedRequest, ResolvedBindings, Solutions, AnOutput, Accepted, AcceptedBindings, EssentialBindings)
        if [AnOutput != ''] then
             [Output := AnOutput]
             [ContinueLooking := false]
             return
        end
    )

    go:dialog_update_center()
    go:find_response(Accepted, AcceptedBindings, ResponseBindings, ResponseIndex)
    go:create_answer(Accepted, ResponseBindings, ResponseIndex, Answer)
    go:dialog_write_bindings(ResponseBindings)
    go:dialog_add_response_clause(EssentialBindings)
    go:generate(Locale, Answer, OutTokens)
    go:surface(OutTokens, Output)
    [ContinueLooking := false]
;

go:exec_solutions(ResolvedRequest, ResolvedBindings, Solutions, Output, Accepted, AcceptedBindings, EssentialBindings) :-
    go:list_length(Solutions, SolSize)
    [LastSol := [SolSize - 1]]
    [:Output := '']
    [:Accepted := none]
    [:AcceptedBindings := none]
    [:EssentialBindings := none]

    go:list_foreach(Solutions, Index, Sol,

        go:solve(ResolvedRequest, ResolvedBindings, Sol, ResultBindings, ResultCount, EssentialBindings1)

        /* If there were solutions, good! */
        if [ResultCount > 0] then
            [:Accepted := Sol]
            [:AcceptedBindings := ResultBindings]
            [:EssentialBindings := EssentialBindings1]
            [:Output := '']
            break
        end
        /* If this is the last available solution, take it anyway */
        if [LastSol == Index] then
            [:Accepted := Sol]
            [:AcceptedBindings := ResultBindings]
            [:EssentialBindings := EssentialBindings1]
            [:Output := '']
            break
        end
    )
    [Output := :Output]
    [Accepted := :Accepted]
    [AcceptedBindings := :AcceptedBindings]
    [EssentialBindings := :EssentialBindings]
;