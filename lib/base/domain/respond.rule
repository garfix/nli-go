go:tell(Input) :-
    go:uuid(Uuid)
    go:assert(
        go:goal(
            go:respond(Input),
            Uuid));

go:respond(Input) :-

    /* We use a mutable variable here because there can be Outputs that may be overridden later */
    [:Output = '']

    go:ignore(

        go:find_locale(Locale)
        go:slot(locale, Locale)
        go:dialog_read_bindings(DialogBinding)
        go:tokenize(Locale, Input, InTokens)
        go:parse(Locale, InTokens, ParseTree)

        /* Stop at the first successfully processed parse tree */
        go:cut(1,
            go:dialogize(ParseTree, DialogParseTree)
            go:ellipsize(DialogParseTree, CompletedParseTree)
            go:extract_root_clauses(CompletedParseTree, RootClauseTree)
            go:process_root_clause(RootClauseTree, Request, DialogBinding, Locale, RootClauseOutput, ContinueLooking)
            [:Output = RootClauseOutput]

            /* `ContinueLooking` tells us that there was a problem that should only be reported if no other parse tree succeeds */
            if go:equals(ContinueLooking, true) then
                fail
            end
        )
    )
    go:uuid(Uuid)
    go:wait_for(
        go:print(Uuid, :Output)
    )
;

go:process_root_clause(RootClauseTree, Request, DialogBinding, Locale, Output, ContinueLooking) :-

    go:dialog_add_root_clause(RootClauseTree, false)
    go:relationize(RootClauseTree, Request, DialogBinding, RequestBinding, UnresolvedName)

    if go:not_equals(UnresolvedName, '')
    then
        go:create_canned(Output, name_not_found, UnresolvedName)
        [ContinueLooking = true]
        return
    end

    /* Stop at the first successfully processed solution */
    go:cut(1,
        go:find_solution(Request, Solution)
        go:make_list(Solutions, Solution)
        go:exec_solutions(Request, RequestBinding, Solutions, AnOutput, Accepted, AcceptedBindings, EssentialBindings)
        if go:not_equals(AnOutput, '') then
             [Output = AnOutput]
             [ContinueLooking = false]
             return
        end
    )

    go:dialog_write_bindings(AcceptedBindings)
    go:dialog_update_center()
    go:find_response(Accepted, AcceptedBindings, ResponseBindings, ResponseIndex)
    go:create_answer(Accepted, ResponseBindings, ResponseIndex, Answer)
    go:dialog_write_bindings(ResponseBindings)
    go:dialog_add_response_clause(EssentialBindings)
    go:generate(Locale, Answer, OutTokens)
    go:surface(OutTokens, Output)
    [ContinueLooking = false]
;

go:exec_solutions(Request, RequestBinding, Solutions, Output, Accepted, AcceptedBindings, EssentialBindings) :-
    go:list_length(Solutions, SolSize)
    go:subtract(SolSize, 1, LastSol)
    go:list_foreach(Solutions, Index, Sol,

        go:solve(Request, RequestBinding, Sol, ResultBindings, ResultCount, SolveOutput, EssentialBindings1)

        /* If there was a problem, or a request for clarification, stop */
        if go:not_equals(SolveOutput, '') then
            [Output = SolveOutput]
            return
        end
        /* If there were solutions, good! */
        if go:greater_than(ResultCount, 0) then
            [Accepted = Sol]
            [AcceptedBindings = ResultBindings]
            [EssentialBindings = EssentialBindings1]
            [Output = '']
            return
        end
        /* If this is the last available solution, take it anyway */
        if go:equals(LastSol, Index) then
            [Accepted = Sol]
            [AcceptedBindings = ResultBindings]
            [EssentialBindings = EssentialBindings1]
            [Output = '']
            return
        end
    )
;