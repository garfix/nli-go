
/* move the block in the hand to a free space */
do_get_rid_of(E1) :-
    do_find_space_on_table(E1, X, Y)
    do_put_on_table(E1, X, Y);

do_put_on_table(E1, X, Y) :-
    do_move(E1, X, Y, 0);

/* if there is a block in the hand, it is put down */
do_clear_hand(_) :- go:or(
    go:not(grasping(`:shrdlu`, _)),
    grasping(`:shrdlu`, E1) do_get_rid_of(E1)
);

/* remove all blocks that are on top of X */
do_cleartop(E1) :- cleartop(E1);
do_cleartop(E1) :- support(E1, E2) do_cleartop(E2) do_get_rid_of(E2);

top_center_to_bottom_corner(E1, X, Y, Z, X1, Y1, Z1) :-
    size(E1, Width, Length, Height)
    go:divide(Width, 2, Wh) go:divide(Length, 2, Lh)
    go:subtract(X, Wh, X1) go:subtract(Y, Lh, Y1) go:subtract(Z, Height, Z1);

bottom_corner_to_top_center(E1, X, Y, Z, X1, Y1, Z1) :-
    size(E1, Width, Length, Height)
    go:divide(Width, 2, Wh) go:divide(Length, 2, Lh)
    go:add(X, Wh, X1) go:add(Y, Lh, Y1) go:add(Z, Height, Z1);

do_find_space_on_table(E1, X1, Y1) :-
    do_find_free_space(`table:table`, E1, X1, Y1);

do_find_iter(X, Y, SugX, SugY) :- go:if_then_else(
    at(E, SugX, SugY, _),
    go:add(SugX, 10, A) do_find_iter(X, Y, A, SugY) ,
    go:unify(X, SugX) go:unify(Y, SugY)
);

create_plan_for_stack(QBlocks, SortedList) :-
    go:quant_ordered_list(QBlocks, &by_easiness, List)
    go:list_order(List, &by_size, SortedList)
    go:list_length(SortedList, Size)
    go:subtract(Size, 1, Last)
    go:list_foreach(SortedList, Index, E1,
        go:if_then(
            go:not_equals(Index, Last) go:not(block(E1)),
            go:cancel()
        )
    );

stack_up_proper(List1, X, Y) :-
    go:let(Base, `table:table`)
    go:list_foreach(List1, E1,
        do_cleartop(E1)
        go:if_then_else(
            go:equals(Base, `table:table`),
            block(E1) do_put_on_table(E1, X, Y),
            block(Base) go:unify(B1, Base) do_put_on(E1, B1)
        )
        go:let(Base, E1)
    );

by_easiness(E1, E2, R) :-
    go:if_then_else(
        pyramid(E1),
        go:if_then_else( pyramid(E2), go:unify(R, 0), go:unify(R, 1) ),
        go:if_then_else( pyramid(E2), go:unify(R, -1),
            go:if_then_else( cleartop(E1),
                go:if_then_else( cleartop(E2), go:unify(R, 0), go:unify(R, -1) ),
                go:if_then_else( cleartop(E2), go:unify(R, 1), go:unify(R, 0) ) )
        )
    );

/* Order decreasingly by width or depth */
by_size(E1, E2, R) :-
    go:if_then_else(
        pyramid(E1),
        go:unify(R, 1),

        go:if_then_else(
            pyramid(E2),
            go:unify(R, -1),

            size(E1, Width1, Depth1, _)
            size(E2, Width2, Depth2, _)
            go:if_then_else(
                go:equals(Width1, Width2),
                go:compare(Depth2, Depth1, R),
                go:if_then_else(
                    go:equals(Depth1, Depth2),
                    go:compare(Width2, Width1, R),
                    go:min(Width1, Depth1, Min1) go:min(Width2, Depth2, Min2) go:compare(Min2, Min1, R)
                )
            )
        )
    );

/* Create a description for an object in the world */
describe(E1, DescSet) :-

    /* Is the shape unique? */
    shape(E1, S)
    go:if_then_else(
        shape(E2, S) go:number_of(E2, 1),
        go:unify(DescSet, description(E1) shape(E1, S)),

        /* Is the combination of shape and color unique? */
        color(E1, C)
        go:if_then_else(
            shape(E2, S) color(E2, C) go:number_of(E2, 1),
            go:unify(DescSet, description(E1) shape(E1, S) color(E1, C)),

            /* Is the combination of shape, color and volume (big, small) unique? */
            volume(E1, V)
            go:if_then_else(
                shape(E2, S) color(E2, C) volume(E2, V) go:number_of(E2, 1),
                go:unify(DescSet, description(E1) shape(E1, S) color(E1, C) volume(E1, V)),

                /* Add the object it supports and presume that this is enough */
                support(E1, E3) describe(E3, E3Desc)
                go:unify(DescSet,
                    description(E1) shape(E1, S) color(E1, C) volume(E1, V)
                    support(E1, E3)
                    description(E3) {{ E3Desc }})
            )
        )
    );


/* Create a general description for an object in the world */
describe_categoric(E1, DescSet) :-

    /* Is the shape unique? */
    shape(E1, S)
    go:if_then_else(
        shape(E2, S) go:number_of(E2, 1),
        go:unify(DescSet, description(E1) shape(E1, S)),

        /* Is the combination of shape and color unique? */
        color(E1, C)
        go:if_then_else(
            shape(E2, S) color(E2, C) go:number_of(E2, 1),
            go:unify(DescSet, description(E1) shape(E1, S) color(E1, C)),

            /* Is the combination of shape, color and volume (big, small) unique? */
            volume(E1, V)
            go:unify(DescSet, description(E1) shape(E1, S) color(E1, C) volume(E1, V))
        )
    );
