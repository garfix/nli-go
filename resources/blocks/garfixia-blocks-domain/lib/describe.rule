describe_as_groups(List) => GroupList, Description {

    GroupFeatures := []
    GroupMembers := []

    /* group elements */
    for I, E1 in List {
        for volume(E1, V) color(E1, C) form(E1, F) {
            Features := [V, C, F]
            if2 go:list_index(GroupFeatures, Features, Index) {
                Group := GroupMembers[Index]
                Group []= E1
                GroupMembers[Index] := Group
            } else {
                GroupFeatures []= Features
                GroupMembers []= [E1]
            }
        }
    }

    /* describe groups */
    GroupList := []
    Description := none
    for Index, Members in GroupMembers {

        one { go:list_length(Members, MemberCount) }
        one { go:uuid(G, object) }

        GroupList []= G

        Features := GroupFeatures[Index]
        Volume := Features[0]
        Color := Features[1]
        Form := Features[2]

        CountForm := 0
        CountColor := 0
        CountVolume := 0

        for form(E2, Form) {
            CountForm := [CountForm + 1]
        }
        for form(E2, Form) color(E2, Color) {
            CountColor := [CountColor + 1]
        }
        for form(E2, Form) color(E2, Color) volume(E2, Volume) {
            CountVolume := [CountVolume + 1]
        }

        Description := [Description + { description(G) shape(G, Form) }]

        if2 [MemberCount > 1] {
            Description := [Description + { number(G, MemberCount) }]
        }

        /* Is the shape unique? */
        if2 [CountForm > 1] {
            Description := [Description + { color(G, Color) }]

            /* Are the shape and color unique? */
            if2 [CountColor > 1] {
                Description := [Description + { volume(G, Volume) }]
            }
        }

    }
};


/* Create a description for an object in the world */
describe(E1, Sort) => Set {

    one { form(E1, S) color(E1, C) volume(E1, V) }

    Cs := 0
    Cc := 0
    Cv := 0

    for form(E2, S) {
        Cs := [Cs + 1]
    }
    for form(E2, S) color(E2, C) {
        Cc := [Cc + 1]
    }
    for form(E2, S) color(E2, C) volume(E2, V) {
        Cv := [Cv + 1]
    }

    Set := { description(E1) default_shape(E1, Sort) shape(E1, S) }

    /* Is the shape unique? */
    if2 [Cs > 1] {
        Set := [Set + { color(E1, C) }]
        /* Are the shape and color unique? */
        if2 [Cc > 1] {
            Set := [Set + { volume(E1, V) }]
            /* Are the shape, color, and volume unique? */
            if2 [Cv > 1] {
                /* Add the object it supports and presume that this is enough */
                if2 support(now, E1, E3) {
                    E3Desc := describe(E3, Sort)
                    Set := [[Set + { support(now, E1, E3) description(E3) }] + E3Desc]
                }
            }
        }
    }
};

/* Create a description that uses indeterminate nouns in stead of complex refinements */
describe_categoric(E1, Sort) => DescSet {

    one { form(E1, S) color(E1, C) volume(E1, V) }

    Cs := 0
    Cc := 0
    Cv := 0

    for form(E2, S) {
        Cs := [Cs + 1]
    }
    for form(E2, S) color(E2, C) {
        Cc := [Cc + 1]
    }
    for form(E2, S) color(E2, C) volume(E2, V) {
        Cv := [Cv + 1]
    }

    Set := none

    if2 go:dialog_get_center(L1) [E1 == L1] {
        Set := { center(E1) }
    } else {
        if2 name(E1, Name) {
            Set := [Set + { name(E1, Name) shape(E1, S) }]
        } else {
            Set := { description(E1) default_shape(E1, Sort) shape(E1, S) }

            /* Is the shape unique? */
            if2 [Cs > 1] {
                Set := [Set + { color(E1, C) }]
                /* Are the shape and color unique? */
                if2 [Cc > 1] {
                    Set := [Set + { volume(E1, V) indeterminate(E1) }]
                }
            }
        }
    }
    DescSet := Set
};

describe_event(P1, DescSet) :-
    pick_up(P1, Subject, Object)
    ItemDesc := describe_categoric(Object, '')
    DescSet := [{ pick_up(P1, Subject, Object) } + ItemDesc]
;

describe_event(P1, DescSet) :-
    put_on(P1, Subject, Object1, Object2)
    ItemDesc1 := describe_categoric(Object1, '')
    ItemDesc2 := describe_categoric(Object2, '')
    DescSet := [[{ put_on(P1, Subject, Object1, Object2) } + ItemDesc1] + ItemDesc2]
;

describe_event(P1, DescSet) :-
    put_in(P1, Subject, Object1, Object2)
    ItemDesc1 := describe_categoric(Object1, '')
    ItemDesc2 := describe_categoric(Object2, '')
    DescSet := [[{ put_in(P1, Subject, Object1, Object2) } + ItemDesc1] + ItemDesc2]
;

describe_event(P1, DescSet) :-
    stack_up(P1, Subject, List)
    go:list_expand(List, Item)
    ItemDesc := describe_categoric(Item, '')
    DescSet := [{ stack_up(P1, Subject, List) } + ItemDesc]
;

describe_event(P1, DescSet) :-
    get_rid_of(P1, Subject, A)
    ItemDesc := describe_categoric(A, '')
    DescSet := [{ get_rid_of(P1, Subject, A) } + ItemDesc]
;

describe_event(P1, DescSet) :-
    clear_off(P1, Subject, A)
    ItemDesc := describe_categoric(A, '')
    DescSet := [{ clear_off(P1, Subject, A) } + ItemDesc]
;
