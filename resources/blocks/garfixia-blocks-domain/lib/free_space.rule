/*
    Inspired by https://www.geeksforgeeks.org/maximum-size-sub-matrix-with-all-1s-in-a-binary-matrix/

    Finds an area big enough to house an object E1 within the boundaries of Container.
    First it collects all left and right boundaries of all objects in Container, together with the container boundary, and places them in VerLines.
    It does the same for the upper and lower boundaries and places them in HorLines.
    Then it creates a grid from these lines and fills the occupied places with 1.
    To actually determine the free space, it goes through all columns.
    For each column, it calculates the number of columns to the right needed to house the width of E1 (the "span").
    Within the column, for each row, it finds out if the span is free, and accumulates the length of the row.
    Once the accumulated length is big enough for the length of the object E1, the space is found.
*/

/* Returns the lower-left point of a space inside given bounds that is big enough for E1 */
do_find_free_space(Container, E1) => X1, Y1 {
    one { rectangle(Container, BoundX1, BoundX2, BoundY1, BoundY2) }

    HorLines1, VerLines1, Objects := do_find_objects(Container, BoundX1, BoundY1, BoundX2, BoundY2)

    do_init_grid(fixed, Objects, HorLines1, VerLines1)

    X1, Y1 := do_find_free_position(E1, fixed, HorLines1, VerLines1)
    [X1 != -1]
};

rectangle(R1, X1, X2, Y1, Y2) :-
    at(R1, X1, Y1, _)
    size(R1, Width, Length, _)
    X2 := [X1 + Width]
    Y2 := [Y1 + Length]
;

do_find_objects(Container, BoundX1, BoundY1, BoundX2, BoundY2) => H3, V3, Objects {

    V1 := [BoundX1, BoundX2]
    H1 := [BoundY1, BoundY2]
    Objects := []

    for rectangle(O1, X1, X2, Y1, Y2) {

        if [O1 != Container] go:isa(O1, object) [X2 >= BoundX1] [X1 <= BoundX2] [Y2 >= BoundY1] [Y1 <= BoundY2] {

            Objects []= O1

            if [X1 >= BoundX1] [X1 <= BoundX2] {
                V1 []= X1
            }
            if [X2 >= BoundX1] [X2 <= BoundX2] {
                V1 []= X2
            }

            if [Y1 >= BoundY1] [Y1 <= BoundY2] {
                H1 []= Y1
            }
            if [Y2 >= BoundY1] [Y2 <= BoundY2] {
                H1 []= Y2
            }
        }
    }

    V2 := go:list_deduplicate(V1, rv)
    H2 := go:list_deduplicate(H1, rv)
    V3 := go:list_sort(V2, rv)
    H3 := go:list_sort(H2, rv)
};

do_init_grid(Grid, Objects, HorLines, VerLines) {
    go:retract( grid(Grid, _, _, _) )

    for I1, O1 in Objects {
        for rectangle(O1, X1, X2, Y1, Y2) {
            V1 := go:list_index(VerLines, X1, rv)
            V2 := go:list_index(VerLines, X2, rv)
            H1 := go:list_index(HorLines, Y1, rv)
            H2 := go:list_index(HorLines, Y2, rv)

            for V in V1 to [V2 - 1] {
                for H in H1 to [H2 - 1] {
                    go:assert( grid(Grid, H, V, 1) )
                }
            }
        }
    }
};

do_find_free_position(E1, Grid, HorLines, VerLines) => FoundX, FoundY {
    FoundX := -1
    FoundY := -1
    StartY := -1
    MinScore := 100000000

    for at(E1, X1, Y1, _) size(E1, Width, Length, _) {

        CenterX := [X1 + [Width / 2]]
        CenterY := [Y1 + [Length / 2]]

        for XIndex, X in VerLines {
            StartY := HorLines[0]
            XEndIndex := find_span(Width, VerLines, XIndex)
            EndX := VerLines[XEndIndex]
            for YIndex, Y in HorLines {
                if [YIndex > 0] {
                    if span_free(XIndex, XEndIndex, [YIndex - 1], Grid) {
                        SpanLength := [Y - StartY]
                        if [SpanLength >= Length] {
                            DX := [X - CenterX]
                            DY := [StartY - CenterY]
                            Score := [DX + DY]

                            /* go for the lowest Score */
                            SpanWidth := [EndX - X]
                            if [Score < MinScore] {
                                MinScore := Score
                                FoundX := X
                                FoundY := StartY
                            }
                        }
                    } else {
                        StartY := Y
                    }
                }
            }
        }
    }
};

find_span(Width, VerLines, XIndex) => XEndIndex {
    X1 := VerLines[XIndex]
    XEndIndex := XIndex
    for Index, X2 in VerLines {
        W := [X2 - X1]
        if [W >= Width] {
            XEndIndex := Index
            break
        }
    }
};

span_free(ColStart, ColEnd, RowIndex, Grid) => Success {
    Success := true

    for XIndex in ColStart to ColEnd {

        for grid(Grid, RowIndex, XIndex, 1) {
            Success := false
            break
        }

        if [Success == false] {
            break
        }
    }
};
