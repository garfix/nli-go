[
    /* these commands need to be robust; they must clear up any previous state of holding a block */

    /* make sure the following relations stay in tact */
    /* contain() support() cleartop() at() */

    /* after making sure you can, pick up an object and hold it in the hand */
    do_pick_up_smart(P1, E1) :-
        do_clear_hand(_)
        do_cleartop(E1)
        do_pick_up(E1);

    do_put_in_smart(P1, E1, E2) :-
        do_clear_hand(_)
        do_cleartop(E1)
        do_put_in(E1, E2);

    do_stack_up_smart(P1, QBlocks) :-
        do_clear_hand(_)
        quant_ordered_list(QBlocks, by_easiness, List)
        list_order(List, by_size, SortedList)
        unify(X, 678) unify(Y, 678) /* todo: find a proper place */
        stack_up_proper(SortedList, X, Y);

    stack_up_proper(List1, X, Y) :-
        list_foreach(List1, E1,
            block(E1)
            do_cleartop(E1)
            if_then_else(
                at(Base, X, Y, _) cleartop(Base), /* find the topmost object on the stack */
                do_put_on(E1, Base),
                do_put_on_table(E1, X, Y)
            )
        );

    by_easiness(E1, E2, R) :-
        if_then_else(
            pyramid(E1),
            if_then_else( pyramid(E2), unify(R, 0), unify(R, 1) ),
            if_then_else( pyramid(E2), unify(R, -1),
                if_then_else( cleartop(E1),
                    if_then_else( cleartop(E2), unify(R, 0), unify(R, -1) ),
                    if_then_else( cleartop(E2), unify(R, 1), unify(R, 0) ) )
            )
        );

    /* Order decreasingly by width or depth */
    by_size(E1, E2, R) :-
        size(E1, Width1, Depth1, _)
        size(E2, Width2, Depth2, _)
        if_then_else(
            equals(Width1, Width2),
            compare(Depth2, Depth1, R),
            if_then_else(
                equals(Depth1, Depth2),
                compare(Width2, Width1, R),
                min(Width1, Depth1, Min1) min(Width2, Depth2, Min2) compare(Min2, Min1, R)
            )
        );
]
